# Search Algorithm

## 1 Binary Search

Binary Search，即二搜索（查找）。每轮搜索将搜索的数组砍半，以节省搜索时间，通常时间复杂度为 $O(logN)$。常用于 **有序数组的搜索** 中！

LeetCode 上有很多二分搜索的题，基本上都带有 **“有序”** 二字，因此需要格外注意！

但实际上，能够使用二分搜索的情况：

- **数据状况特殊**：如有序数组
- **问题本身特殊**：如局部最小值

如果能够构建起 **排他性** 的东西（一半有，一半没有），就可以使用二分。

### 常见的应用

通常，二分搜索可以解决以下问题：

- 在一个有序数组中，找某个值是否存在

- 在一个有序数组中，找 $\ge$ 某个数最左侧的位置

  > 如：`[1,3,4,5,5,5,7,8]` 中找 $\ge$ 5 最左侧的位置，返回 index 为 3。 

- 在一个有序数组中，找 $\le$ 某个数最右侧的位置

- **无序数组** 中的局部最小值

  > 无序数组中，任意两个相邻的数不相等。所谓局部最小，即 `arr[i-1] > arr[i] < arr[i+1]`，此时 `arr[i]` 称为局部最小值。


前三个比较好理解，关键是第四个问题怎么解决？

### 无序数组中的局部最小值

无序数组中，任意两个相邻的数不相等。所谓局部最小，即 `arr[i-1] > arr[i] < arr[i+1]`，此时 `arr[i]` 称为局部最小值。只需要求出任一个局部最小值即可。

第一步，我们先检查数组两端的元素，则出现三种情况。

![IMG_5912](https://tva1.sinaimg.cn/large/008vxvgGgy1h83muz0yrnj31t30u0dmd.jpg)

第二步，我们找到 `arr[mid]`，让它与 `arr[mid-1]` 和 `arr[mid+1]` 比较，然后根据结果进行返回，或者进一步二分。

![IMG_5913](https://tva1.sinaimg.cn/large/008vxvgGgy1h83mw5v0kxj31720u0wiv.jpg)

本题的题目特点，即 **局部最小的趋势**，是能够使用二分的关键！！

