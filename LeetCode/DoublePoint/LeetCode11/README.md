# LeetCode11：盛最多水的容器

## 题目描述

> https://leetcode.cn/problems/container-with-most-water/description/

给定一个长度为 `n` 的整数数组 `height` 。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。返回容器可以储存的最大水量。

**说明：**你不能倾斜容器。

**示例 1：**

![img](https://tva1.sinaimg.cn/large/008vxvgGgy1h86nlo9qe2j30m90ant8v.jpg)

```
输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```

**示例 2：**

```
输入：height = [1,1]
输出：1 
```

**提示：**

- `n == height.length`
- `2 <= n <= 10^5`
- `0 <= height[i] <= 104`

## 思路与分析

### 暴力枚举

暴力枚举是最直接的方法，但数组长度会到达 $10^5$ ，显然时间复杂度必须小于 $O(N^2)$ ，否则会超时。

```java
class Solution {
    public int maxArea(int[] height) {
        int res = 0;
        for (int i = 0; i < height.length - 1; i++) {
            for (int j = i + 1; j < height.length; j++) {
                res = Math.max(res, (Math.min(height[i], height[j])) * (j - i));
            }
        }
        return res;
    }
}
```

![image-20221116081926959](https://tva1.sinaimg.cn/large/008vxvgGgy1h86nnzlt6kj30nh062wfp.jpg)

### 双指针法

题目中的示例为：

```
[1, 8, 6, 2, 5, 4, 8, 3, 7]
 ^                       ^
```

在初始时，左右指针分别指向数组的左右两端，它们可以容纳的水量为 `min⁡(1,7) ∗ 8 = 8` 。

**此时我们需要移动一个指针**。移动哪一个呢？直觉告诉我们，应该移动对应数字较小的那个指针（即此时的左指针）。这是因为，由于容纳的水量是由下式决定的：
$$
两个指针指向的数字中较小值∗指针之间的距离
$$
如果我们移动数字较大的那个指针，那么前者「两个指针指向的数字中较小值」不会增加，后者「指针之间的距离」会减小，那么这个乘积会减小。即：

- 指针向内移动，必定会导致指针之间的距离减少
- 移动对应数字较大的指针：指针之间距离减少，数字也（有可能）减少，**因此面积一定不增！**
- 移动对应数字较小的指针：指针之间距离减少，但数字（有可能）增加，**因此面积有可能增加！**
- 两个指针对应的元素相同，移动任意一个均可！

因此，我们移动数字较大的那个指针是不合理的。因此，**我们移动数字较小的那个指针**。

所以，我们将左指针向右移动：

```
[1, 8, 6, 2, 5, 4, 8, 3, 7]
    ^                    ^
```

此时可以容纳的水量为 $min⁡(8,7)∗7=49$ 。由于右指针对应的数字较小，我们移动右指针：

```
[1, 8, 6, 2, 5, 4, 8, 3, 7]
    ^                 ^
```

此时可以容纳的水量为 `min⁡(8,3)∗6=18` 。由于右指针对应的数字较小，我们移动右指针：

```
[1, 8, 6, 2, 5, 4, 8, 3, 7]
    ^              ^
```

此时可以容纳的水量为 `min⁡(8,8)∗5=40` 。两指针对应的数字相同，我们可以任意移动一个，例如左指针：

```
[1, 8, 6, 2, 5, 4, 8, 3, 7]
       ^           ^
```

由于左指针对应的数字较小，我们移动左指针，并且可以发现，在这之后左指针对应的数字总是较小，因此我们会一直移动左指针，直到两个指针重合。

```java
class Solution {
    public int maxArea(int[] height) {
        int l = 0;
        int r = height.length - 1;
        int res = 0;
        while (l < r) {
            res = Math.max(res, (r - l) * Math.min(height[r], height[l]));
            if (height[l] <= height[r]) {
                l++;
            } else {
                r--;
            }
        }
        return res;
    }
}
```

**复杂度分析**

- 时间复杂度： $O(N)$ ，双指针总计最多遍历整个数组一次。
- 空间复杂度： $O(1)$ ，只需要额外的常数级别的空间。

### 为什么双指针是正确的？

> 双指针代表了什么？

双指针代表的是 **可以作为容器边界的所有位置的范围**。在一开始，双指针指向数组的左右边界，表示 **数组中所有的位置都可以作为容器的边界**，因为我们还没有进行过任何尝试。在这之后，我们每次将 **对应的数字较小的那个指针** 往 **另一个指针** 的方向移动一个位置，就表示我们认为 **这个指针不可能再作为容器的边界了**。

> 为什么对应的数字较小的那个指针不可能再作为容器的边界了？

在上面的分析部分，我们对这个问题有了一点初步的想法。这里我们定量地进行证明。

考虑第一步，假设当前左指针和右指针指向的数分别为 $x$ 和 $y$ ，不失一般性，我们假设 $x \leq y$ 。同时，两个指针之间的距离为 $t$ 。那么，它们组成的容器的容量为：
$$
min(x,y)*t=x*t
$$
我们可以断定，如果我们保持左指针的位置不变，那么无论右指针在哪里，这个容器的容量都不会超过 $x∗t$ 了。

> 最后的答案是什么？

答案就是我们每次以双指针为左右边界（也就是「数组」的左右边界）计算出的容量中的最大值。

## REFERENCE

https://leetcode.cn/problems/container-with-most-water/solutions/207215/sheng-zui-duo-shui-de-rong-qi-by-leetcode-solution/
