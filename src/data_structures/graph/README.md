# 图

## 图结构的描述

- 由点的集合和边的集合构成
- 虽然存在有向图和无向图的概念，但实际上都可以使用有向图来表示
- 边上可带有权值

设计图中的点类：

```java
public class Node {

    // 值
    private int value;

    // 入度
    private int in;

    // 出度
    private int out;

    // 邻居节点
    private ArrayList<Node> nexts;

    // 邻接边
    private ArrayList<Edge> edges;

    public Node(int value, int in, int out, ArrayList<Node> nexts, ArrayList<Edge> edges) {
        this.value = value;
        this.in = in;
        this.out = out;
        this.nexts = nexts;
        this.edges = edges;
    }
}
```

设计图中的边类：

```java
public class Edge {

    // 边上的权重
    private int weight;

    // 边的起始节点
    private Node from;

    // 边的结束节点
    private Node to;

    public Edge(int weight, Node from, Node to) {
        this.weight = weight;
        this.from = from;
        this.to = to;
    }
}
```

图类：

```java
public class Graph {
    // 点集
    public HashMap<Integer, Node> nodes;
    // 边集
    public HashSet<Edge> edges;

    public Graph() {
        nodes = new HashMap<>();
        edges = new HashSet<>();
    }
}
```

## 经典题型

### 宽度优先遍历

与树的宽度优先遍历相似，都是使用队列进行遍历。区别在于这里需要使用额外的 `set` 来防止回路。

具体步骤：

- 节点入队
- 若 `set` 中没有该节点，则入 `set`；否则不入
- 节点出队，访问节点
- 节点的邻接节点入队，回到第一步

### 深度优先遍历

遍历方法：递归（或迭代） + `set`。同样，`set` 也是用来防止走环路的。

具体步骤：

- 节点入栈
- 节点入 set
- 访问节点（入栈时访问）
- 弹出节点，遍历当前节点的邻居节点集
  - 如果发现邻居节点在 set 中，则跳过
  - 如果发现邻居节点不在 set 中，则
    - 重新压入当前弹出节点
    - 邻居节点入栈并访问
    - 邻居节点入 set
    - 跳出遍历邻居节点集

在遍历时，**栈中保存的内容，一定是当前遍历的一整条路径！**

### 图的拓扑排序算法

要求：**有向无环图**

拓扑排序：

- 在图中找出所有入度为 0 的节点输出
- 把所有入度为 0 的点在图中删掉，继续找入度为 0 的点输出，周而复始
- 图中所有的点都被删掉后，依次输出的顺序就是 **拓扑排序**
- 拓扑排序不唯一

要求：

- 有向图且没有环

应用场景：

- 事件安排、编译顺序

可以使用 `BFS` 或 `DFS` 生成拓扑排序。下面几个技巧也可用来做拓扑排序。

> **【Note 1】** 如果一个节点 `x` 后续点次 **大于** 节点 `y` 后续点次，则 `x` 的拓扑序小于等于 `y` 的拓扑序。
>
> **【Note 2】** 如果一个节点 `x` 在图中能够走出的最大深度大于等于 `y` ，则 `x` 的拓扑序小于等于 `y` 的拓扑序。

### 最小生成树

树（tree）是一种特殊的图，一个图要成为树要满足三个条件：

- 该图是一个 **无向图** （准确意义上来说，有根树的父子节点间的关系也可以算是有向边）
- 该图 **连通** （即图上任意两点都可以互相到达）
- 该图 **无环** （即图上任意两点间 **有且只有** 一条 **简单路径** ）

生成树（spanning tree）是一个图的子图，它的定义如下

- 它是一颗无根树
- 它包含原图的 **所有节点**

**最小生成树（minimum spanning tree）** 其实就是一个生成树，不过它不同于一般的生成树，它的边权之和是最小的，即边权和最小的生成树，准确的来说，同一个图的最小生成树也可以有很多个，但是其边权和肯定是一样的。

#### Kruscal算法

> KrusKal 本质上是一个贪心的过程。

具体步骤：

- 总是从权值最小的边开始考虑，依次考察权值依次变大的边
- 当前的边要么进入最小生成树的集合，要么丢弃
- 如果当前的边进入最小生成树的集合中不会形成环，就要当前边
- 如果当前的边进入最小生成树的集合会形成环，就不要当前边
- 考察完所有边后，最小生成树的集合就得到了

怎么有效地合并和判断环呢？**并查集！**

- 将边添加入图时，就进行并查集中的合并
- 判断是否构成环，就是判断两个节点是不是在同一个集合中

#### Prim算法

具体步骤：

- 可以从任意节点出发来寻找最小生成树
- 某个节点加入到被选取的节点后，解锁这个点出发的所有新的边
- 在所有解锁的边中选择最小的边，然后看看这个边会不会形成环
  - 如果会，不要当前边，继续考察剩下解锁边中最小的边，重复3
  - 如果不会，则选取当前边，将该边的指向点加入被选择的点中，重复2
- 如果所有点都被选取，最小生成树就得到了

### 单源最短路：狄杰斯特拉算法

**Dijkstra** 要求：有向图，**非负权值**
具体步骤：

- `dist[]` 存储第 i 个节点到其余点的距离，`visited[i]=true` 代表第 i 个点是否已经遍历过。
- 遍历所有 `visited[i] == false` 的点，找出 `dist[i]` 最小的点 k。
- 遍历与 k 相连的点 j，用 `min(dist[j], dist[k] + edge[k][j])` 来更新 `dist[j]` 。
- 将 `visited[k] = true;`
- 如果还存在点，返回2



















