# 并查集

## 基本介绍

1. 并查集是一种树型的数据结构，用于处理一些不相交集合（disjoint sets）的 **合并及查询** 问题。

2. 并查集通常包含两种操作

- 查找 (Find)：查询两个元素是否在同一个集合中
- 合并 (Union)：把两个不相交的集合合并为一个集合

先来看看并查集最直接的一个应用场景：**亲戚问题**。

> **题目背景**
>
> 若某个家族人员过于庞大，要判断两个是否是亲戚，确实还很不容易，现在给出某个亲戚关系图，求任意给出的两个人是否具有亲戚关系。
>
> **题目描述**
>
> 规定：x和y是亲戚，y和z是亲戚，那么x和z也是亲戚。如果x,y是亲戚，那么x的亲戚都是y的亲戚，y的亲戚也都是x的亲戚。
>
> **输入格式**
>
> 第一行：三个整数n,m,p，（n<=5000,m<=5000,p<=5000），分别表示有n个人，m个亲戚关系，询问p对亲戚关系。以下m行：每行两个数Mi，Mj，1<=Mi，Mj<=N，表示Mi和Mj具有亲戚关系。接下来p行：每行两个数Pi，Pj，询问Pi和Pj是否具有亲戚关系。
>
> **输出格式**
>
> P行，每行一个’Yes’或’No’。表示第i个询问的答案为“具有”或“不具有”亲戚关系。

这其实是一个很有现实意义的问题。我们可以建立模型，把所有人划分到若干个不相交的集合中，每个集合里的人彼此是亲戚。为了判断两个人是否为亲戚，只需看它们是否属于同一个集合即可。因此，这里就可以考虑用并查集进行维护了。

### 流程

并查集的重要思想在于，**用集合中的一个元素代表集合**。把集合比喻成**帮派**，而代表元素则是**帮主**。

![img](https://pic4.zhimg.com/80/v2-09fa3fa35e5411444b327d9cb9a31057_720w.webp)

最开始，所有大侠各自为战。他们各自的帮主自然就是自己。*（对于只有一个元素的集合，代表元素自然是唯一的那个元素）*

现在1号和3号比武，假设1号赢了（这里具体谁赢暂时不重要），那么3号就认1号作帮主*（合并1号和3号所在的集合，1号为代表元素）*。

![img](https://pic4.zhimg.com/80/v2-3bf6c1a6ecf87fa93f4dbab2012446c7_720w.webp)

现在2号想和3号比武*（合并3号和2号所在的集合）*，但3号表示，别跟我打，让我帮主来收拾你*（合并代表元素）*。不妨设这次又是1号赢了，那么2号也认1号做帮主。

![img](https://pic4.zhimg.com/80/v2-be12a6c795572d2acd77dcd49de35127_720w.webp)

现在我们假设4、5、6号也进行了一番帮派合并，江湖局势变成下面这样：

![img](https://pic1.zhimg.com/80/v2-3c353bc781c7f3553079d541a9cfdc28_720w.webp)

现在假设2号想与6号比，跟刚刚说的一样，喊帮主1号和4号出来打一架（帮主真辛苦啊）。1号胜利后，4号认1号为帮主，当然他的手下也都是跟着投降了。

![img](https://pic3.zhimg.com/80/v2-6362d8b13705d5ba17b19cdeee453022_720w.webp)

好了，比喻结束了。如果你有一点图论基础，相信你已经觉察到，这是一个**树**状的结构，要寻找集合的代表元素，只需要一层一层往上访问**父节点**（图中箭头所指的圆），直达树的**根节点**（图中橙色的圆）即可。

## 经典题目

### 朋友圈

一个班有N个学生。有些是朋友，有些不是。他们的友谊在本质上是可传递的。例如，如果A是B的直接朋友，B是C的直接朋友，那么A是C的间接朋友。定义朋友圈是一群学生的直接朋友或间接朋友。

给出一个 `N*N` 矩阵M，表示班级中同学之间的朋友关系。如果 `M[i][j] = 1`，则第i个和第j个学生之间是直接的朋友，否则不是。你需要输出所有学生的朋友圈总数。

Example 1:
Input:

```java
[[1,1,0],
 [1,1,0],
 [0,0,1]]
```

Output: 2
Explanation: 0和1是直接的朋友，所以他们在一个朋友圈里。第二个学生自己在一个朋友圈里。返回2。

Example 2:
Input:

```java
[[1,1,0],
 [1,1,1],
 [0,1,1]]
```

Output: 1
Explanation: 第0位和第1位是直接朋友，第1位和第2位是直接朋友，所以0和2是间接的朋友。它们都在同一个朋友圈，所以返回1。

#### 方法：并查集

一开始每个人都是一个集合，然后对所有人进行遍历。如果有相互认识的情况，就进行集合的合并操作（Union）。

最后返回代表节点的个数（也就是集合的个数）。

















## 参考

https://zhuanlan.zhihu.com/p/93647900



















