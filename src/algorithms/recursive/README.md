# 暴力递归

## 基本介绍

暴力递归就是尝试。

- 把问题转化为规模缩小了的同类的子问题
- 有明确的不需要继续进行递归的条件（base case）
- 有当得到了子问题的结果之后的决策过程
- 不记录每一个子问题的解

## 经典题型

### 汉诺塔问题

> https://leetcode.cn/problems/hanota-lcci/

在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:

- 每次只能移动一个盘子;
- 盘子只能从柱子顶端滑出移到下一根柱子;
- 盘子只能叠在比它大的盘子上。

请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。

你需要原地修改栈。

**示例1:**

```
 输入：A = [2, 1, 0], B = [], C = []
 输出：C = [2, 1, 0]
```

**示例2:**

```
 输入：A = [1, 0], B = [], C = []
 输出：C = [1, 0]
```

**提示:** A 中盘子的数目不大于14个。

#### 方法

假设需要将 N 个碟子从 A 移动到 C：

- 先将 N-1 个碟子，从 A 移动到 B
- 然后将 剩下那一个碟子，从 A 移动到 C
- 最后将 N-1 个碟子，从 B 移动到 C

其中，第一步和第三步都是递归实现。

```java
class Solution {
    // A: from
    // B: other
    // C: to
    public void hanota(List<Integer> A, List<Integer> B, List<Integer> C) {
        int N = A.size();
        move(N, A, B, C);
    }

    // 将N个圆盘从A柱经由B柱移动到C柱
    void move(int N, List<Integer> A, List<Integer> B, List<Integer> C) {
        if (N == 1) {
            C.add(0, A.remove(0));
            return;
        }
        // 将 N-1 个圆盘移动到 B 柱
        move(N - 1, A, C, B);
        C.add(0, A.remove(0));
        move(N - 1, B, A, C);
    }
}
```

N 层汉诺塔问题的需要 $O(2^N - 1)$ 步。

### 打印字符串的全部子序列



### 打印字符串的全部排列



### 逆序栈

给定一个栈，请你逆序一个栈，不能申请额外的数据结构，只能使用递归函数，如何实现？









































