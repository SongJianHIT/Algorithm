# 最长递增子序列（LIS）

给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

**示例 1：** 

```
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```

**示例 2：** 

```
输入：nums = [0,1,0,3,2,3]
输出：4
```

**示例 3：** 

```
输入：nums = [7,7,7,7,7,7,7]
输出：1
```

**提示：** 

- $1 <= nums.length <= 2500$ 
- $-10^4 <= nums[i] <= 10^4$ 

**进阶：** 

- 你能将算法的时间复杂度降低到 `O(nlog(n))` 吗?

## 经典解法：序列DP

本题将 `dp[i]` 表示为：以 `nums[i]` 结尾的 LIS 最大长度，最后的返回值是 `dp` 数组上的最大值。

遍历到 `index = i` 时，对每个 `j < i`，只要满足 `nums[j] < nums[i]`，就尝试使用 `dp[j]` 去更新 `dp[i]`。

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int n = nums.length;
        // dp[i]：以 nums[i] 结尾的 LIS 最长长度
        int[] dp = new int[n];
        // dp初始化
        for (int i = 0; i < n; ++i) {
            dp[i] = 1;
        }
        int ans = 1;
      	// dp过程
        for (int i = 1; i < n; ++i) {
          	// 尝试每个在 i 前面的元素 j
            for (int j = 0; j < i; ++j) {
                if (nums[j] < nums[i]) {
                  	// 只要满足「严格递增」，就尝试更新 dp[i]
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            ans = Math.max(ans, dp[i]);
        }
        return ans;
    }
}
```

时间复杂度： $O(N^2)$

空间复杂度： $O(N)$ 

## 最优解法：DP+贪心+二分

> **这个最优解非常重要，因为很多问题可以转化为 LIS 问题**，而 LIS 问题的最优解法的时间复杂度为 $O(NlogN)$ 。

假设数组：`[3,4,1,2,8,5,6]`，对于 **长度相同 的递增子序列，哪一个更好呢？**

- [1,2,8]
- [3,4,5]

当然是 `[3,4,5]` 更好，因为在 **长度相同** 的情况下，**末尾的数组越小，则后续变长的可能性就越大！**

因此，我们通过这种 `贪心` 的思路优化一下 `dp` 的定义：

> `dp[i]`：当子序列长度是 `i+1` 时，子序列最小的末尾元素大小。

因此，在遍历数组时，当前元素 `nums[i]` 有两种可能：

- 如果 `nums[i]` 大于当前最长子序列的末尾元素，则它会 **扩充最长子序列！**
- 可能去 **替代相同长度的子序列的末尾最小元素**

最后题目的答案就是 `dp` 数组的长度。

<img src="最长递增子序列.assetsmage-20230217115733983.png" alt="image-20230217115733983" style="zoom:50%;" />

这里以第三行为例子：

`dp = [1, 4]` 表示，当前长度为 1 的子序列最小末尾元素是 1；当前长度为 2 的子序列末尾最小元素为 4。

观察 `dp` 数组，**可以发现它一定是单调递增的，因此可以使用二分搜索！**

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int n = nums.length;
        int[] tails = new int[n];
        int res = 0;
        for (int num : nums) {
            int l = 0, r = res;
            // 二分搜索插入位置
            while (l < r) {
                int mid = l + ((r - l) >> 1);
                if (tails[mid] < num) {
                    l = mid + 1;
                } else {
                    r = mid;
                }
            }
            tails[l] = num;
            if (res == l) {
                res++;
            }
        }
        return res;
    }
}
```

时间复杂度：$O(NlogN)$ 

空间复杂度：$O(N)$ 

















































































