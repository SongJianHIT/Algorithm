# 动态规划

## 基本介绍

动态规划（英语：Dynamic programming，简称 DP），是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。

动态规划常常适用于 **有重叠子问题** 和 **最优子结构** 性质的问题。

动态规划最核心的思想，就在于 **拆分子问题，记住过往，减少重复计算**。



## 经典题型

### 题目一：机器人移动

假设有排成一行的 N 个位置，记为 1～N，N 一定大于等于 2。

开始时，机器人在其中的 M 位置上（M 一定是 1～N 中的一个）

- 如果机器人来到 1 位置，那么下一步只能往右走来到 2 位置
- 如果机器人来到 N 位置，那么下一步只能往左走来到 N-1 位置
- 如果机器人在中间位置，那么下一步只能往左走或者往右走

规定机器人必须走 K 步，最终能到达 P 位置的方法有多少种。给定参数 N，M，K，P，返回方法数。

### 题目二：拿牌问题

给定一个整型数组 arr，代表数值不同的纸牌排成一条线。

玩家 A 和玩家 B 依次拿走每张纸拍。规定 A 先拿，B 后拿。但是每个玩家每次都只能拿走 **最左** 或 **最右** 的纸牌。

玩家 A 和玩家 B 都绝顶聪明，请返回最后获胜者的分数。

### 题目三：背包问题

**01背包问题**：每个元素最多取1次。具体来讲：一共有 N 件物品，第 i（i 从 1 开始）件物品的重量为 w[i]，价值为 v[i]。在总重量不超过背包承载上限 W 的情况下，能够装入背包的最大价值是多少？

### 题目四：数字字符转字符串

规定 1 与 A 对应，2 与 B 对应，3 与 C 对应，...，26 与 Z 对应。

那么一个数字字符串，如 "111" 可转化为 "AAA","KA","AK"。

给定一个只有数字字符组成的字符串 `str`，返回有多少种转化结果。

### 题目五：贴纸拼词

我们有 `n` 种不同的贴纸。每个贴纸上都有一个小写的英文单词。

您想要拼写出给定的字符串 `target` ，方法是从收集的贴纸中切割单个字母并重新排列它们。如果你愿意，你可以多次使用每个贴纸，每个贴纸的数量是无限的。

返回你需要拼出 `target` 的最小贴纸数量。如果任务不可能，则返回 `-1` 。

**注意：**在所有的测试用例中，所有的单词都是从 `1000` 个最常见的美国英语单词中随机选择的，并且 `target` 被选择为两个随机单词的连接。 

**示例 1：**

```
输入： stickers = ["with","example","science"], target = "thehat"
输出：3
解释：
我们可以使用 2 个 "with" 贴纸，和 1 个 "example" 贴纸。
把贴纸上的字母剪下来并重新排列后，就可以形成目标 “thehat“ 了。
此外，这是形成目标字符串所需的最小贴纸数量。
```

**示例 2:**

```
输入：stickers = ["notice","possible"], target = "basicbasic"
输出：-1
解释：我们不能通过剪切给定贴纸的字母来形成目标“basicbasic”。
```

**提示:**

- `n == stickers.length`
- `1 <= n <= 50`
- `1 <= stickers[i].length <= 10`
- `1 <= target.length <= 15`
- `stickers[i]` 和 `target` 由小写英文单词组成

### 题目六：最长公共子序列

给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ，返回 `0` 。

一个字符串的 **子序列** 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

- 例如，`"ace"` 是 `"abcde"` 的子序列，但 `"aec"` 不是 `"abcde"` 的子序列。

两个字符串的 **公共子序列** 是这两个字符串所共同拥有的子序列。

**示例 1：**

```
输入：text1 = "abcde", text2 = "ace" 
输出：3  
解释：最长公共子序列是 "ace" ，它的长度为 3 。
```

**示例 2：**

```
输入：text1 = "abc", text2 = "abc"
输出：3
解释：最长公共子序列是 "abc" ，它的长度为 3 。
```

**示例 3：**

```
输入：text1 = "abc", text2 = "def"
输出：0
解释：两个字符串没有公共子序列，返回 0 。
```

**提示：**

- `1 <= text1.length, text2.length <= 1000`
- `text1` 和 `text2` 仅由小写英文字符组成。

### 题目七：最长回文子序列

给你一个字符串 `s` ，找出其中最长的回文子序列，并返回该序列的长度。

子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。

**示例 1：**

```
输入：s = "bbbab"
输出：4
解释：一个可能的最长回文子序列为 "bbbb" 。
```

**示例 2：**

```
输入：s = "cbbd"
输出：2
解释：一个可能的最长回文子序列为 "bb" 。
```

**提示：**

- `1 <= s.length <= 1000`
- `s` 仅由小写英文字母组成

### 题目八：象棋马走日

整个象棋棋盘放入第一象限，棋盘最左下角是 (0, 0) 位置，那么整个棋盘就是横坐标上 9 条线，纵坐标上 10 条线的区域。

给定三个参数 `x, y, k`，返回 马 从 `(0,0)` 位置出发，必须走 `k` 步，最后落在 `(x,y)` 上的方法数有多少种？

### 题目九：路径累加和问题

给定一个二维数组 matrix，一个人必须从左上角出发，最后到达右下角，沿途只能向下或者向右走，沿途的数字的累加就是距离累加和，返回最小距离累加和。

> 本题说明的是 **dp 表压缩问题**。只要以后遇到题目有“依赖左边、依赖上边”都可以将 dp 表压缩为 dp 数组。
>
> - 先填第一行
> - 随后每行，先填第一列
> - 然后比较左边和当前元素，即可完成更新

### 题目十：凑钱

arr 是货币数组，其中的值都是正数。再给定一个正数 aim。每个值都认为是一张货币，即便是值相同的货币也认为每一张都是不同的，返回组成 aim 的方法数。

例如：`arr={1,1,1}, aim=2`，则一共有 3 种方法（第0个1和第1个1组成2，第0个1和第2个1组成2，第1个1和第2个1组成2）。

### 题目十一：凑钱2

arr 是面值数组，其中的值都是正数且没有重复。再给定一个正数 aim。每个值都认为是一种面值，且认为张数是无限的，返回组成 aim 的方法数。

例如：`arr={1,2}, aim=4`，则方法共有 3 种（`1+1+1+1, 2+2, 1+1+2`）

> **严格表结构是记忆化搜索的增加依赖版本，从表的简单位置填到复杂位置。**
>
> 【重点】
>
> - 如果单独一个格子，**没有枚举行为**（即只依赖有限几个位置），则记忆化搜索和严格表结构同样好！
> - 有枚举行为的话（每个单独的格子需要 for 循环计算），严格表结构能够优化，看位置！

### 题目十二：凑钱3

arr 是货币数组，其中的值都是正数。再给定一个正数 aim。每个值都认为是一张货币，认为值相同的货币没有任何不同，返回组成 aim 的方法数。

例如：`arr={1,2,1,1,2,1,2}, aim=4`，则一共有 3 种方法（`1+1+1+1, 2+2, 1+1+2`）。

### 题目十三：醉汉行走

给定5个参数，`N,M,row,col,k` 表示在 `N*M` 的区域上，醉汉 Bob 初始在 (row, col) 的位置上，一共要迈出 k 步，且每步都会等概率向上下左右四个方向走一个单位。任何时候 Bob 只要离开 `N*M` 的区域，就会死亡。返回 k 步之后，Bob 还在 `N*M` 区域的概率。

### 题目十四：打怪兽

给定三个参数，`N, M, K`。怪兽有 `N` 滴血，等着英雄砍自己。英雄每一次打击，都会让怪兽流失 `[0~M]` 的血量，具体流失多少血，每次在 `[0~M]` 上等概率的获取一个值。求 K 次打击之后，英雄把怪兽看似的概率。

### 题目十五：凑钱4

arr 是面值数组，其中的值都是正数且没有重复。再给定一个正数 aim。每个值都认为是一种面值，且认为张数是无限的，返回组成 aim 的最少货币数。

### 题目十六：分裂数字

给一个数字，进行分裂，后面的数字不能比前面的数字小。

如：`3` 的裂开方法有 `1+1+1, 1+2, 3`

### 题目十七：分裂数组

给定一个正数数组 arr，请把 arr 中所有的数分成两个集合，尽量让两个集合的累加和接近。返回：最接近的情况下，较小集合的累加和。

例如：`{3, 4, 1, 5}`，拆成 `{3, 4}` 和 `{1, 5}`，返回小的累加和 `6`。

### 题目十七：分裂数组2

给定一个正数数组 arr，请把 arr 中所有的数分成两个集合，如果 arr 长度为偶数，两个集合包含数的个数要一样多，如果 arr 长度为奇数，两个集合包含数必须之差一个。尽量让两个集合的累加和接近。返回：最接近的情况下，较小集合的累加和。













