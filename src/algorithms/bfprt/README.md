# bfprt算法

## 基本介绍

**BFPTR算法**，又称为 **中位数的中位数算法**，它的最坏时间复杂度为 $O(n)$ ，它是由 **Blum、Floyd、Pratt、Rivest、Tarjan** 提出。该算法的思想是 **修改快速选择算法的主元选取方法**，提高算法在最坏情况下的时间复杂度。

以：在无序数组中求第 K 小的数为例。

### 算法流程

1. 将数组按 5 个元素一组划分成 **N/5 个小部分**（最后不足5个元素自成一个部分），此步骤的时间复杂度为 $O(1)$
2. 在每个小组内进行排序，此步骤的时间复杂度为 $O(N)$
3. 将每个小组的 **中位数** 取出来，组成新的数组 $m$，数组大小为 $5/N$。重复步骤1和步骤2，递归下去，直至剩下一个数字
4. 最终剩下的数就是 `pivot`，把小于它的数全放左边，等于它的放中间，大于它的数全放右边
5. 判断 `pivot` 的位置与 k 的大小，有选择地选择左边或右边递归

**这么做的好处**：保证每次递归排除了 $3/10$ 的数，新一轮迭代 **最多** $7/10$ 的数。

## 经典题目

### 题目一：无序数组中第K小的数

给定一个无序数组，求其中第 K 小的数。

#### 解法1：改进的快排

快排中，随机选择一个数做荷兰国旗问题，时间复杂度为 $O(N)$。假设随机选择的数为 `v`，那么做一次划分得到：`arr=[ <v | =v | >v]`。观测 `=v` 的区间：

- 如果第 K 小的数正好落在 `=v` 的区间内，直接返回 `v` 即可
- 如果第 K 小的数不在 `=v` 的区间内，则根据大小，从对应区域中再随机选一个数进行荷兰国旗划分，直至满足条件一

该方法的时间复杂度为 $O(N)$。

#### 解法2：bfprt算法

1. 将数组按 5 个元素一组划分成 **N/5 个小部分**（最后不足5个元素自成一个部分），此步骤的时间复杂度为 $O(1)$
2. 在每个小组内进行排序，此步骤的时间复杂度为 $O(N)$
3. 将每个小组的 **中位数** 取出来，组成新的数组 $m$，数组大小为 $5/N$。重复步骤1和步骤2，递归下去，直至剩下一个数字
4. 最终剩下的数就是 `pivot`，把小于它的数全放左边，等于它的放中间，大于它的数全放右边
5. 判断 `pivot` 的位置与 k 的大小，有选择地选择左边或右边递归

