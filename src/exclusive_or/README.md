# exclusive OR

**异或运算（exclusive OR）**：二机制的运算方式，**相同为 0，不同为 1**，也可以直接记为 **无进位相加**。

但通常题目会考察异或的一些特殊性质。

## 异或的性质

异或的重要性质：

- $0\ {\wedge}\ N = N$
- $N\ {\wedge}\ N = 0$
- 满足交换律： $a\ {\wedge}\ b = b\ {\wedge}\ a$ 
- 满足结合律： $a\ {\wedge}\ (b\ {\wedge}\ c)= (a\ {\wedge}\ b)\ {\wedge}\ c $ 

## 异或的作用

### 不使用额外变量交换两个数

常见方式：

```java
int tmp = a;
a = b;
b = tmp;
```

但怎么不使用 `tmp` 就能实现交换呢？使用异或这个骚操作！

```java
a = a ^ b;
b = a ^ b;	// 相当于 b = a ^ b ^ b = a
a = a ^ b;	// 相当于 a = a ^ b ^ a = b
```

### 特定数组中查找一个重复奇数次的数

一个数组中，有一个数出现了奇数次，其他数都出现了偶数次，怎么找到并打印该数？

直接想法可以使用 `HashMap` 来寻找。那么怎么只有一个变量就能找到呢？

```java
eor = 0
// 使用 eor 从头异或到尾，剩下的值就是那个重复了奇数次数的值，返回即可
[3, 3, 3, 5, 6, 6, 5]
// 无论数组顺序如何，由于存在交换律和结合律，一定有：
eor = 3 ^ 3 ^ 3 ^ 5 ^ 5^6^6 = 3
```

### 特定数组中查找两个不同的重复奇数次的数

一个数组中，有两个不同的数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两个数？

要解决这个问题，首先要来看如何解决：

> 怎么把一个 int 类型的数，提取出最右侧的 1 来？
>
> 如： $(101010111011000)_2$  的最右侧的 `1` 为 $(000000000001000)_2$ 。

解决方法： $A\  \& \  (\neg A +1)$ 

```java
A  								= 101010111011000
~A 								= 010101000100111
~A + 1  					    = 010101000101000
A & (~A + 1)			        = 000000000001000
```

那好，有了这个结论，我们回到原问题。有两个不同的数，即 $A \neq B$ ，那么我们在做异或的时候：

```java
eor = 0
// 从头异或到尾后
eor = a ^ b
```

既然 $A \neq B$ ，那么 `eor` 一定不为 0，`eor` 的二进制一定在某位有1。我们取 `eor` 最右侧的 1，假设该位是第三位。那我们就知道 A 的第三位与 B 的第三位不一样，我们就可以将 `arr` 整个分成两类：

- 第三位上是 1 的数
- 第三位上是 0 的数

然后分别在这两类上全部异或，得到两个结果就是这两个数！

### 进一步改进题目

一个数组中，有一个数出现了 `K` 次，其他数都出现了 `M` 次，`M > 1, K < M` 。要求找到出现了 `K` 次的数。并要求，额外空间复杂度 $O(1)$ ，时间复杂度 $O(N)$ 。

> 如果不做空间复杂度的要求，可以直接使用 `HashMap` 进行求解，时间复杂度也能到 `O(N)` 。

第一步，创建一个长度为 32 的数组 `t` ，用来保存 `int` 类型的二进制数。

```java
// t = [0,1,0,1,0,0,0, ... , 0]
int t = new int[32];
```

第二步，遍历原数组 `arr` ，对每一个数组中的数，求其二进制，然后累加到 `t` 中。这样，我们就得到一个累加所有二进制位的数组 `t` ，`t[i]` 表示 `arr` 中所有数在 `i` 位上为 1 的个数。

```java
// 例如，有 8 个 1 和 3 个 4, 求完 t 后：
t = [0,0,0,..., 3,0,0,8]
```

第三步，让 `t[i] ` 对 `M` 求余，若余数不为0，则说明，我们要求的数（出现 `k` 次）在 `i` 位上有 1。通过循环和左移，可求出答案。